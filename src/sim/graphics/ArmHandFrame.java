package sim.graphics;


import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.WindowEvent;
import java.awt.*;
import java.util.StringTokenizer;
import java.io.InputStreamReader;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.DataOutputStream;

import sim.motor.ArmHand;
import sim.util.Elib;
import sim.main.Main;

import javax.swing.*;
import javax.swing.event.ChangeListener;
import javax.swing.event.ChangeEvent;

/**
 *
 * @author Erhan Oztop, 2001-2002 <br>
 * <br>
 * Source code by Erhan Oztop (erhan@atr.co.jp) <br>
 * Copyright August 2002 via <br>
 * University of Southern California Ph.D. publication copyright <br>
 */

public class ArmHandFrame extends JFrame implements ActionListener, ChangeListener
{
    ArmHand hand;
    JPanel mainpan;
    JPanel bot,realbot;
    JTextField filename;
    JSlider timeline;
    JLabel timelabel;
    public double timeScale=1.0/10000;
    static final int timeQ=10000;

    JButton close;
    JButton execute;
    JButton visReach;
    JButton clearTraj;
    JButton load;
    JButton save;
    JButton takeSnapshot;
    JButton clearSnapshots;

    public ArmHandFrame(final ArmHand h)
    {
        //Label sep;
        hand=h;
        setLayout(new BorderLayout());
        bot=new JPanel();
        bot.setLayout(new GridLayout(0,4));
        realbot=new JPanel();
        realbot.setLayout(new GridLayout(0,3));
        realbot.setBackground(Color.orange);
        realbot.setForeground(Color.black);
        close=new JButton("CLOSE");
        bot.add(close);
        close.addActionListener(this);
        close.setBackground(Color.white);
        close.setForeground(Color.blue);
        load=new JButton("LOAD");
        bot.add(load);
        load.addActionListener(this);
        save=new JButton("SAVE");
        bot.add(save);
        save.addActionListener(this);
        takeSnapshot=new JButton("TAKE SNAPSHOT");
        bot.add(takeSnapshot);
        takeSnapshot.addActionListener(this);
        clearSnapshots = new JButton("CLEAR SNAPSHOTS");
        bot.add(clearSnapshots);
        clearSnapshots.addActionListener(this);
        bot.add(new JLabel("Gesture file:",Label.RIGHT));
        bot.add(filename=new JTextField("gestures/ok.ges",20));
        execute=new JButton("EXECUTE");
        bot.add(execute);
        execute.addActionListener(this);
        execute.setBackground(Color.orange);
        visReach=new JButton("VISREACH");
        bot.add(visReach);
        visReach.addActionListener(this);
        clearTraj=new JButton("CLEARTRAJ");
        bot.add(clearTraj);
        clearTraj.addActionListener(this);

        mainpan=new JPanel();
        mainpan.setBackground(Color.white);
        mainpan.setLayout(new GridLayout(26,2));
        placePanel(hand.root);

        //timeline=new Scrollbar(Scrollbar.HORIZONTAL, 0, 1, 0, timeQ);
        timeline=new JSlider(JSlider.HORIZONTAL, 0, timeQ, 1);
        //timeline.addAdjustmentListener(this);
        timeline.addChangeListener(this);
        final Panel timepanel=new Panel();
        timepanel.setLayout(new GridLayout(1,1));
        mainpan.add(timelabel=new JLabel("time: 0"));
        timelabel.setBackground(Color.orange);

        timepanel.setBackground(Color.orange);
        timepanel.add(timeline);
        mainpan.add("Center",timepanel);

        add("Center",mainpan);
        add("North",bot);
        add("South",realbot);

        enableEvents(AWTEvent.WINDOW_EVENT_MASK);

        hand.visualProcessor.reset(hand.segc);
    }

    private void writeConfig(String fn)
    {
        try
        {
            DataOutputStream patout = Elib.openfileWRITE(fn);
            patout.writeBytes("# This hand gesture file is generated by HV system (ObjectFrame module) (Erhan Oztop -Feb'00)\n\n");
            patout.writeBytes("Gesture "+fn+"     -at least the file name is this\n");
            patout.writeBytes("Speed "+ Main.self.speedCombo.getSelectedItem()+'\n');
            patout.writeBytes("Ratios ");
            for(int i=0; i<hand.visualProcessor.viaPointIdx; i++)
            {
                patout.writeBytes(hand.visualProcessor.viaPointRatios[i]+"   ");
            }
            patout.writeBytes("\n");
            for (int i=0;i<hand.segc;i++)
            {
                Segment s=hand.seg[i];
                if (s.minbeta==s.maxbeta)
                    continue;
                if (s.joint_axis==null)
                    continue;
                patout.writeBytes(s.label+"    ");
                for(int j=0; j<hand.visualProcessor.viaPointIdx; j++)
                    patout.writeBytes(Elib.snice(hand.visualProcessor.viaPointSnapshots[j][i],1e3,6)+"   ");
                patout.writeBytes("\n");
            }
            patout.close();
        }
        catch (IOException e)
        {
            System.err.println("Write gesture : EXCEPTION "+e);
        }
        System.out.println("Wrote gesture file in "+fn);
    }

    private void loadConfig(String fn)
    {
        try
        {
            hand.visualProcessor.reset(hand.segc);
            BufferedReader patin = new BufferedReader(new InputStreamReader(Elib.openfileREAD(fn)));
            String s;
            while(patin.ready())
            {
                s=patin.readLine();
                if(s!=null && s.length()>0 && s.charAt(0)!='#')
                {
                    StringTokenizer st = new StringTokenizer(s, " ");
                    if(st.hasMoreTokens())
                    {
                        String t = st.nextToken();
                        if (t.equals("Gesture"))
                        {}
                        else if (t.equals("Speed"))
                        {
                            Main.self.speedCombo.setSelectedItem(st.nextToken());
                        }
                        else if (t.equals("Ratios"))
                        {
                            hand.visualProcessor.viaPointIdx=0;
                            while(st.hasMoreTokens())
                            {
                                hand.visualProcessor.viaPointRatios[hand.visualProcessor.viaPointIdx++]=Double.parseDouble(st.nextToken());
                            }
                        }
                        else
                        {
                            hand.visualProcessor.viaPointIdx=0;
                            int jointIdx = hand.findSegment(t);
                            while(st.hasMoreTokens())
                            {
                                hand.visualProcessor.viaPointSnapshots[hand.visualProcessor.viaPointIdx++][jointIdx] = Double.parseDouble(st.nextToken());
                            }
                        }
                    }
                }
            }
            // target joint angles
            hand.theta1 =new double[hand.segc];
            hand.storeAngles(hand.theta1);
            final double[] target=new double[hand.segc];
            System.arraycopy(hand.visualProcessor.viaPointSnapshots[hand.visualProcessor.viaPointIdx-1], 0, target, 0,
                    hand.segc);
            // via point joint angles
            final double[][] viaPoints=new double[hand.visualProcessor.viaPointIdx-1][hand.segc];
            final double[] viaRatios=new double[hand.visualProcessor.viaPointIdx-1];
            if(viaPoints.length>0)
            {
                for(int i=0; i<hand.visualProcessor.viaPointIdx-1; i++)
                    System.arraycopy(hand.visualProcessor.viaPointSnapshots[i], 0, viaPoints[i], 0, hand.segc);
                System.arraycopy(hand.visualProcessor.viaPointRatios, 0, viaRatios, 0, hand.visualProcessor.viaPointIdx-1);
                hand.lasttr=hand.trimTrajectory(target,viaPoints,viaRatios);
            }
            else
                hand.lasttr=hand.trimTrajectory(target);
        }
        catch(Exception e)
        {
            System.err.println("Load gesture : EXCEPTION "+e);
        }
        System.out.println("Loaded gesture file from "+fn);
    }

    private void placePanel(final Segment s)
    {
        if (s.minbeta!=s.maxbeta) // if not moveable don't show
        {
            final JPanel p=s.makePanel("");
            if (p!=null)
            {
                mainpan.add(p);
                s.beta_sb.addChangeListener(this);
            }
        }
        for (int i=0;i<s.noch;i++)
            placePanel(s.child[i]);
    }

    public void closeSelf()
    {
        unplacePanel(hand.root);
        this.dispose();
    }

    private static void unplacePanel(final Segment s)
    {
        s.unmakePanel();
        for (int i=0;i<s.noch;i++)
            unplacePanel(s.child[i]);
    }

    public void updateTime()
    {
        final int int_t=timeline.getValue();
        double realt=int_t*timeScale;
        timelabel.setText("time: "+realt);
        sim.main.Main.refreshDisplay();
    }

    protected void processWindowEvent(final WindowEvent e)
    {
        if(e.getID() == WindowEvent.WINDOW_CLOSING)
            closeSelf();
    }

    public void stateChanged(final ChangeEvent e)
    {
        final Segment seg=whichSegment(e.getSource());
        if (seg==null)
        {
            updateTime();
        }
        else
        {
            final double newbeta=seg.beta_sb.getValue()*Math.PI/1800;
            ArmHand.constrainedRotate(seg,newbeta-seg.beta);
            sim.main.Main.refreshDisplay();
        }
    }

    Segment whichSegment(final Object t)
    {
        for (int i=0;i<hand.root.segc;i++)
        {
            if (hand.root.seg[i].seg_pan!=null)
                if (hand.root.seg[i].beta_sb==t)
                    return hand.root.seg[i];
        }
        return null;
    }

    public void actionPerformed(final ActionEvent e)
    {
        if (e.getActionCommand().equals("CLOSE"))
        {
            closeSelf();
        }
        else if (e.getActionCommand().equals("EXECUTE"))
        {
            Main.self.toggleReach("execute");
        }
        else if (e.getActionCommand().equals("VISREACH"))
        {
            Main.self.toggleReach("visual");
        }
        else if (e.getActionCommand().equals("CLEARTRAJ"))
        {
            hand.clearTrajectory();
        }
        else if (e.getActionCommand().equals("TAKE SNAPSHOT"))
        {
            takeSnapshot();
        }
        else if (e.getActionCommand().equals("CLEAR SNAPSHOTS"))
        {
            hand.visualProcessor.reset(hand.segc);
        }
        else if (e.getActionCommand().equals("SAVE"))
        {
            writeConfig(filename.getText());
        }
        else if (e.getActionCommand().equals("LOAD"))
        {
            loadConfig(filename.getText());
        }
    }

    private void takeSnapshot()
    {
        hand.visualProcessor.viaPointRatios[hand.visualProcessor.viaPointIdx]=timeline.getValue()*timeScale;
        hand.visualProcessor.viaPointSnapshots[hand.visualProcessor.viaPointIdx]=hand.getJointAngleSnapshot(0.0);
        hand.visualProcessor.viaPointIdx++;
    }
}

/*
*
* Erhan Oztop, 2000-2002  <br>
* Source code by Erhan Oztop (erhan@atr.co.jp) <br>
* Copyright August 2002 under <br>
* University of Southern California Ph.D. publication copyright <br>
*/


